\chapter{Discussion}
%
\section{EMF Lexer} The presented \ref{lexer:RefEObj} Lexer extension allows the use of arbitrary serializable objects on the character stream as atomic UTF8 characters. The serializable objects are stored in an adjacent file as values of a map from UTF8 character keys. This file must be delivered and localized together with the original character stream. The Lexer extension allows the textual language to handle complex structured data without describing it, but still requires to declare their existence at a specific location. This makes it impossible for the user to change the declared data. The use of private use UTF8 characters clutters the output text file by the presence of squares, $\square$. The meaning of the squares is completely intransparent for the user, which makes them a high potential error source. If mandatory, their absence invalidates the document and makes it nearly impossible for the user using a normal text editor to return to a valid state. Creating them with a text editor is impossible, copying them from the adjacent document is unacceptable because the meaning of the value in the key value pair where it is copied from is not obvious at best. Private use characters offer a remarkable simple and to the current knowledge only solution to virtually enable deep structured atomic data on the character stream. The disadvantages are severe. Their use outside a particular adapted environment should be avoided. Private characters at the start and the end of a document can be an acceptable exception. 

\section{Notation Model} The notation model is the central component for interchangeable representations of the same language element and especially sensitive to an unstable language model. This concept of an notation model already proved valueable for graphical editors like GMF and also as reduced layout oriented version in by XText. The drawbacks of the notation model is its consumption of resources and its dependency on the stability of the language model. The increased resource consumption of the notation model is due to increased memory consumption of the notation model itself. For an uncompressed model, this results in at least one notation element per token. Keeping old states and providing alternative presentations intensifies memory consumption. \\ %Stable language model
Providing stable language model is the most challenging prerequisite. In stable language model elements are reused and only the ones are altered for which their textual representation is changed. This is not the case for current EMF based textual editing tools. \cite{iSW} offers an incremental solution which reuses nodes to a large extend. Barista\footnote{\raggedright \url{http://www.cs.cmu.edu/~NatProg/barista.html}} adopted and simplified \cite{iSW} algorithm to work on abstract syntax trees \cite{Barista}. It remains open if this adoption is also possible for the parse to abstract syntax tree conversion used by Xtext or in regards to the simplified  version of this thesis. Tree rewrites are necessary in Xtexts grammar because of characteristics of the underlying LL(*) parsing algorithm, but not for Generalized Left-to-right Rightmost derivation parsers, for which \cite{iSW} offers an incremental solution and were therefore excluded in the grammar model of this thesis. \\%Non stable model
If the language model is not stable, recovering the notation model by heuristically compare the old with the new language model is possible, but not regarded further in this thesis. The EMF Compare\footnote{\raggedright \url{http://www.eclipse.org/emf/compare/}} Framework provides a customizable \code{MatchService} to facilitate this approach. \\
It is possible recreate the notation model on each parse based on the notation information which can be deduced from the \emph{current} textual representation. This is the approach used by Xtext for its node model. For the described notation model, this leads to the loose of not deduceable information, like \code{persistedRepresentations} and the need to recalculate \code{alternativeRepresentations}, as well as to \emph{non identical} referenced \code{EObjects} of the language model. In contrast to Xtext, it is import to keep the presented notation model up to date even after pretty printing. The notation model offer the ability to switch between different representations and must be only invalidated by the first textual change. The non identical references are \emph{the} common problem of unstable models, because a new language model is created and some parts might still refer to the old model. Converting the references to proxies containing an URI does not ensure the stability of the referred target. This problem occurred for Xtext only for cross-document references, this problem also occurs in a single document if using ID characters. In detail, this problem occurs only if elements of the \code{EObject} graph refer to textual representations, not to other \code{EObject}s hold by ID characters.\\
The Notation model offers the possibility to switch between different textual presentations using the parse tree constructor or providing the base for sentential characters. The problems regarding the notation model are the increased memory consumption and the non notation model inflicted problem of an unstable language models. 
%magnitude saved old, per token, compressed?

\section{Parse Tree Constructor}
The presented parse tree constructor uses like Xtext and TEF backtracking, which has a runtime of $O(c^N)$. Xtext tries the last valid option first and just requires one valid solution. The requirements for the parse tree constructor for alternative textual representations requires \emph{all} valid solutions. This exponential increase the average runtime, for example for the rule
\begin{xtxt}
R : (v += NUM | x += STR)*
\end{xtxt}
are $( |v| - 1 ) * ( |x| - 1)$ valid solutions. If similar rule exists in the grammar, the parse tree constructor suffers from combinatorial explosion even for small examples.  Alternative textual representations should be calculated \emph{on demand} for a selected element. The time complexity of the parse tree constructor leaves much space for improvement. It remains open if optimizations of GLR parsers, like for example sharing common prefixes and suffixes are possible for parse tree construction on a linearized abstract syntax tree. The parse tree constructor suggested for this thesis is similar to Xtexts parse tree constructor except:
\begin{itemize}
	\item it does not construct trees for valid invisible notation elements
	\item it determines all valid alternatives
	\item the order in which possible solutions are tried can be partly customized. Selected alternatives, so called hints, must be tried first.
	\item it should be extensible to add additional specialized alternatives to the notation model based on optional constraints.
\end{itemize}

\section{Sentential Characters}
Sentential characters are virtually able to contain parts of the parse tree on the characters stream due to the use of the EMF Lexer and the notation model. Preventing the parse tree constructor to construct the parse tree for designated Sentential character requires that the referred language \code{EObject} and its directly and indirectly contained \code{EObject}s are serialized together with the notation model element. By postponing or avoiding the parse tree construction, the elements of the language model are kept in their compact and abstract form. The serialized notation model elements designates the omitted production and thus enables the parse tree constructor together with the referred \code{EObject} to make the postponed parse tree construction up, without the need of any further information. Due to the extensibility of the parse tree constructor, specialized types matching can be created which match additional constraints.  \\
Specialized types are designed to provided in conjunction with graphical editors which use the position of the sentential characters for representation as well as their referred language elements as data source. It is remarkable, that sentential character based editors would be parts of a valid word that is conform to a context free grammar. There would be \emph{no} impedance mismatch integrating sentential character based graphical editors in an existing text. The design time of the graphical editor is decoupled from the grammar or parser. This allows for example library designers to provide a domain specific graphical editor for their library use, which is determined by constraints, \emph{after} the textual language was shipped. This concept also allows various editor extensions of different vendors without mutual knowledge.\\
There are a number of concept related restrictions. The location of the sentential character is fixed, thus, if the editor does not substitute the character at its location, the character must be there and handled. If this character is just hidden, it disables the user to recognize certain problems. Accidental deletion of the character is one, different behavior of the described model depending on if an element is before or after the invisible character is another discouraging example. The integration points are fixed to certain grammar language elements. For example a \code{Sequence} can be substituted, but not an arbitrary sequence, for example \code{b} and \code{c} \emph{together} in the following example\\
\begin{xtxt}
R : a b c d
\end{xtxt}
To handle more generic cases than \code{b} and \code{c}, an additional matching or specialization phase has to be introduced. The graphical editor would furthermore obtain multiple roots with multiple presentation locations. Handling multiple placeholders in a suitable representation is the responsibility of the user interface, and for the \code{b} and \code{c} case merging is conclusive, but for arbitrary cases, like substituting \code{b} and \code{d}, this is demanding.\\
The existence of the editor at a textual location is only a valid possibility if it substitutes a sentential characters. The sentential character is valid if its referred language model satisfies certain constraints. If editing operations of the graphical editor on the language model violate these constraints, the editor render itself invalid at the current position and seizes to exist. Because these constraints for the textual representation are added as validation constraints for the language metamodel, violation is noticed by graphical editors when the model is validated. Restricting the user to make only valid editing operations would be obtrusive and intransparent to the user. It is also common for users using editors, that the transition from one valid to anther valid state contains invalid states. A possible solution for user interface frameworks, which provide graphical editors which possible violate the validation constraints for the sentential character they represent, is to just update the language model if these constraint hold and otherwise lock the language model for other editing operations completely. Another more sophisticated possibility would be based on EMF Model Transactions\footnote{\raggedright \url{http://www.eclipse.org/modeling/emf/?project=transaction}} for the transition between valid states.\\
The effects of unstable language models on Sentential Characters are less intense than for the notation model. This is due to the characteristics that the identity of referred language objects is identified by the Sentential Character. In the case where the textual representation solely describes whole model, and the notation model is rebuild after each reparse, the notation model element which is serialized as a sentential character must contain the referred language \code{EObject}s. Sentential Characters represent the production part, so there is no overlap with other \code{EObjectProduction}s. Because \code{ProductionPart}s contained in \code{EObjectProduction}s depend on the referred language element, editing operations would change attributes \code{EObject} of the reference holding, outer \code{EObjectProduction}. This means that parts of a single language \code{EObject} is edited by text, parts by a graphical editor. For unstable language models, it is possible that the graphical editor changes certain properties of the \code{EObject} where the complete \code{EObject} is then replaces due to changes in the textual version. Therefore, Sentential Characters \emph{must be restricted }to \code{EObjectProduction}s if the language model is unstable. The other restriction of Sentential Characters which they share with ID characters in general is the reference stability. A possible solution would be to use the same intermediate form for resolving references as XText does. Cross-references of serialized \code{EObject}s would be annotated with the textual description of the referred target. The textual editor must update the annotated textual description accordingly, because the user is incapable of doing so. \\
An advantage over independent textual and graphical editors is that changed \code{EObject}s in the graphical editor do not require an update of the textual representation.\\
A conceptional disadvantage of the presented Sentential Token integration by post processing the grammar is the increased size of the parser table, due to replacing every non alternative occurrence $s \in \mathbb{S}$ on the right hand side of a production with $(s | t_S)$. \\
The presented approach of fine grained graphical editors might lead to more, potential functional overlapping editors. For example, if a graphical editor for \code{B} and \code{A} should be provided in the following grammar, this leads to two different graphical editors, where one for \code{B} is likely a subset of the one for \code{A}:
\begin{xtxt}
A : B c
B : b
X : B+
\end{xtxt}
While the concept of Sentential Characters is not specific to certain graphical editor frameworks, a practical solution for graphical editors would requires a specific runtime environment. The main benefit of Sentential Characters, their use as the base for graphical editors depends on the dependencies of these editors. Without further abstraction from the runtime environment, this practically results in an \emph{integrated development environment lock}.

\todo{acidentially delete editor character}
\todo{structure txt bound to model, so gui too}