\chapter{Results}

%%%%%%%%%%%%%%%%%%%%%%%% Discussion%%%%%%%%%%%%%%%%%%%%%%%%
\section{Discussion}

%
\paragraph{EMF Lexer} The presented \ref{lexer:RefEObj} Lexer extension allows the use of arbitrary serializable objects on the character stream as atomic UTF8 characters. The serializable objects are stored in an adjacent file as values of a map from UTF8 character keys. This file must be delivered and localized together with the original character stream. The Lexer extension allows the textual language to handle complex structured data without describing it, but still requires to declare their existence at a specific location. This makes it impossible for the user to change the declared data. The use of private use UTF8 characters clutters the output text file by the presence of squares, $\square$. The meaning of the squares is completely intransparent for the user, which makes them a high potential error source. If mandatory, their absence invalidates the document and makes it nearly impossible for the user using a normal text editor to return to a valid state. Creating them with a text editor is impossible, copying them from the adjacent document is unacceptable because the meaning of the value in the key value pair where it is copied from is not obvious at best. Private use characters offer a remarkable simple and to the current knowledge only solution to virtually enable deep structured atomic data on the character stream. The disadvantages are severe. Their use outside a particular adapted environment should be avoided. Private characters at the start and the end of a document can be an acceptable exception. 

\paragraph{Notation Model} The notation model is the central component for interchangeable representations of the same language element and especially sensitive to an unstable language model. This concept of an notation model already proved valueable for graphical editors like GMF and also as reduced layout oriented version in by XText. The drawbacks of the notation model is its consumption of resources and its dependency on the stability of the language model. The increased resource consumption of the notation model is due to increased memory consumption of the notation model itself. For an uncompressed model, this results in at least one notation element per token. Keeping old states and providing alternative presentations intensifies memory consumption. \\ %Stable language model
Providing stable language model is the most challenging prerequisite. In stable language model elements are reused and only the ones are altered for which their textual representation is changed. This is not the case for current EMF based textual editing tools. \cite{iGLR} offers an incremental solution which reuses nodes to a large extend. Barista\footnote{\raggedright \url{http://www.cs.cmu.edu/~NatProg/barista.html}} adopted and simplified \cite{iGLR} algorithm to work on abstract syntax trees \cite{Barista}. It remains open if this adoption is also possible for the parse to abstract syntax tree conversion used by Xtext or in regards to the simplified  version of this thesis. Tree rewrites are necessary in Xtexts grammar because of characteristics of the underlying LL(*) parsing algorithm, but not for Generalized Left-to-right Rightmost derivation parsers, for which \cite{iGLR} offers an incremental solution and were therefore excluded in the grammar model of this thesis. \\%Non stable model
If the language model is not stable, recovering the notation model by heuristically compare the old with the new language model is possible, but not regarded further in this thesis. The EMF Compare\footnote{\raggedright \url{http://www.eclipse.org/emf/compare/}} Framework provides a customizable \code{MatchService} to facilitate this approach. \\
It is possible recreate the notation model on each parse based on the notation information which can be deduced from the \emph{current} textual representation. This is the approach used by Xtext for its node model. For the described notation model, this leads to the loose of not deduceable information, like \code{persistedRepresentations} and the need to recalculate \code{alternativeRepresentations}, as well as to \emph{non identical} referenced \code{EObjects} of the language model. In contrast to Xtext, it is import to keep the presented notation model up to date even after pretty printing. The notation model offer the ability to switch between different representations and must be only invalidated by the first textual change. The non identical references are \emph{the} common problem of unstable models, because a new language model is created and some parts might still refer to the old model. Converting the references to proxies containing an URI does not ensure the stability of the referred target. This problem occurred for Xtext only for cross-document references, this problem also occurs in a single document if using ID characters. In detail, this problem occurs only if elements of the \code{EObject} graph refer to textual representations, not to other \code{EObject}s hold by ID characters.\\
The Notation model offers the possibility to switch between different textual presentations using the parse tree constructor or providing the base for sentential characters. The problems regarding the notation model are the increased memory consumption and the non notation model inflicted problem of an unstable language models. 

\paragraph{Parse Tree Constructor}
The presented parse tree constructor uses like Xtext and TEF backtracking, which has a runtime of $O(c^N)$. Xtext tries the last valid option first and just requires one valid solution. The requirements for the parse tree constructor for alternative textual representations requires \emph{all} valid solutions. This exponential increase the average runtime, for example for the rule
\begin{xtxt}
R : (v += NUM | x += STR)*
\end{xtxt}
are $( |v| - 1 ) * ( |x| - 1)$ valid solutions. If similar rule exists in the grammar, the parse tree constructor suffers from combinatorial explosion even for small examples.  Alternative textual representations should be calculated \emph{on demand} for a selected element. The time complexity of the parse tree constructor leaves much space for improvement. It remains open if optimizations of GLR parsers, like for example sharing common prefixes and suffixes are possible for parse tree construction on a linearized abstract syntax tree. The parse tree constructor suggested for this thesis is similar to Xtexts parse tree constructor except:
\begin{itemize}
	\item it does not construct trees for valid invisible notation elements
	\item it determines all valid alternatives
	\item the order in which possible solutions are tried can be partly customized. Selected alternatives, so called hints, must be tried first.
	\item it should be extensible to add additional specialized alternatives to the notation model based on optional constraints.
\end{itemize}

\paragraph{Sentential Characters}
Sentential characters are virtually able to contain parts of the parse tree on the characters stream due to the use of the EMF Lexer and the notation model. Preventing the parse tree constructor to construct the parse tree for designated Sentential character requires that the referred language \code{EObject} and its directly and indirectly contained \code{EObject}s are serialized together with the notation model element. By postponing or avoiding the parse tree construction, the elements of the language model are kept in their compact and abstract form. The serialized notation model elements designates the omitted production and thus enables the parse tree constructor together with the referred \code{EObject} to make the postponed parse tree construction up, without the need of any further information. Due to the extensibility of the parse tree constructor, specialized types matching can be created which match additional constraints.  \\
Specialized types are designed to provided in conjunction with graphical editors which use the position of the sentential characters for representation as well as their referred language elements as data source. It is remarkable, that sentential character based editors would be parts of a valid word that is conform to a context free grammar. There would be \emph{no} impedance mismatch integrating sentential character based graphical editors in an existing text. The design time of the graphical editor is decoupled from the grammar or parser. This allows for example library designers to provide a domain specific graphical editor for their library use, which is determined by constraints, \emph{after} the textual language was shipped. This concept also allows various editor extensions of different vendors without mutual knowledge.\\
There are a number of concept related restrictions. The location of the sentential character is fixed, thus, if the editor does not substitute the character at its location, the character must be there and handled. If this character is just hidden, it disables the user to recognize certain problems. Accidental deletion deletion is one, different behavior of the described model depending on if an element is before or after an invisible token is another discouraging example. The integration points are fixed to certain grammar language elements. For example a \code{Sequence} can be substituted, but not an arbitrary sequence, for example \code{b} and \code{c} \emph{together} in the following example\\
\begin{xtxt}
R : a b c d
\end{xtxt}
PREVIOUS prob / sentence

mutiple roots

disables


fixed location
specializer location
amount of graphical editors
% Design time diff



% constraint gui modle
% diff txt and gui presentation orthogonal
% ref to cont. 4 ser

% sentential tokens just eobjects
%refs not lang mod break -> EMF Lexer probs >>>> restrict to eobject sentential tokens
% annotate refs

base for both alternatives to alternative 
xtext alternative txt rep



% because of its existence. 
%magnitude saved old, per token, compressed
% runtime all solutions



\subsection{Achievements}
The concepts described in this th
\begin{itemize}
	\item Multiple Txt rep
	\item Sentential tokens
	\item Editors on lang models
	\item editors in place of symbols and seq. - editors integrate \& conform in CFG!
	\item editors might be added after CFG created, no dep on CFG 2 editors
	\item updating textual view if graphical editor changes something is not necessary in contrast to side by side editors.
	\item sentential tokens might contain data if chars are no additional representation, but this shifts from synchronization to referential integrity problem.
\end{itemize}

\subsection{Drawbacks}
\begin{itemize}
	\item permutations
	\item dependency of editors to CFG (at least declare to)
	\item txt structure structural dependent on model. Just partially a problem, last vis. state can be often recovered.
	\item substitute language seq, but not arbitrary seq
	\item dependencies (stable lang mod)
	\item IDE lock, IDE dependencies
	\item Parse Table++
	\item Mem ++ , Notation Model
	\item Runtime++ O(c$^N$) backtracking 4 all
	\item more, fine grained editors
	\item editor can be lost if it edits the model in a way that the specialized textual representation is not valid any more.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%% Conclusion %%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusion}
\begin{itemize}
	\item Conclusion: Parser generator not the problem and well understood.
\end{itemize}	