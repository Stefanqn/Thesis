\chapter{Related Work}
This chapter starts with the \ref{sec:def} Definitions, where a common understanding of terms are determined and, if necessary, specified. In the next chapter, general non-Metamodeling related approaches of Language Workbenches, language definition and editors are presented. In the final section \ref{sec:metaApproaches} of this chapter, Metamodels are explained and Metamodel related frameworks are presented.

\section{Definitions} \label{sec:def}
This section contains definitions in alphabetical order. 
% A B 
\paragraph{Abstract Syntax} Meta Model elements and their relation are the abstract syntax of a language. \cite{MDSD}

\paragraph{Abstract Syntax Tree (AST)}  
The abstract syntax tree represents the hierarchical syntactic structure of a language.  Abstract syntax trees resemble parse trees to an extent. In the parse tree, interior nodes represent nonterminals including ``helpers'' of one sort of another. In the syntax tree, these helpers are typically dropped \cite{DragonBook}.

\paragraph{Alphabet}
``An alphabet is any finite set of symbols.'' Examples of symbols are letters and digits \cite{DragonBook}.


\paragraph{Ambiguity} 
A grammar which can generate more than one parse tree for a given string of terminals is said to be ambiguous \cite{DragonBook}.

% C D E F G
 
\paragraph{Concrete Syntax} In contrast to the Abstract Syntax, the Concrete Syntax defines the actual representation of the language \cite{MDSD}.

\paragraph{Constraint Satisfaction Problem (CSP) in regard to Parsing} 
Besides answering the question if a word is part of a language, a practical reason for parsing is to obtain the structure of a word to help processing or translating it further. To parse a word according to a grammar means to reconstruct the production tree that indicates how the given word can be produced from the given grammar. This is a specific Constraint Satisfaction Problem (CSP): To consume all tokens on the input stream constrained by the grammar rules. It is possible to build the parse tree by the path taken, or the sequence of rule applications by the parser.  Top-down parsers identify the production rules in post-order, bottom-up parsers tend to identify them in postfix order. This is called Linearization of the Parse Tree \cite{ParserBook}.

\paragraph{Context Free Grammar (CFG)}
A context-free grammar is described by a quadruple, consisting of terminals, nonterminals, a start symbol and productions.\\
$G = (T, V, S, P)$
\begin{enumerate}
	\item \emph{Terminals} are the basic symbols from which words are formed.  They are created by the lexical analyzer.
	\item \emph{Nonterminals} are syntactic variables that denote sets of words. The sets of words denoted by nonterminals help to define the language generated by the grammar. Nonterminals impose a hierarchical structure on the language that is essential to syntax analysis and translation.
	\item One nonterminal in a grammar is distinguished as the \emph{start symbol} which is an element of $V$
	\item The \emph{productions} of a grammar specify how terminals and nonterminals can be combined to form words. Each production consists of:
	\begin{enumerate}
		\item A nonterminal called left side of the production; this production defines some of the words denoted by the left side.
		\item The symbol \code{$\rightarrow$}  or  \code{::=} 
		\item The \emph{right side} consisting of zero or more terminals and nonterminals. The components of the \emph{body} describe one way in which words of the nonterminal at the head can be constructed.
	\end{enumerate}
\end{enumerate}
 $P$ is a finite relation from $V \rightarrow (V  \bigcup  T)^*$, where $^*$ is the Kleene star. Members of $P$ are productions of the form $u \rightarrow v$ \cite{DragonBook}.

\paragraph{Domain} A domain is a delimited area of knowledge or interest \cite{MDSD}.

\paragraph{Domain Specific Language} A Domain Specific Language is a Programming Language for a domain. It consists of abstract and concrete syntax, static semantics as well as a clearly defined semantic of the language elements \cite{MDSD}.

\paragraph{Extended Backus-Naur Form (EBNF)} 
The Backus-Naur Form (BNF) is a notation to describe context-free grammars. It is based on \cite{BNF} and defines \code{:=} and \code{|} as metaliguistic connectives and characters enclosed by \code{<} and \code{>} as metalinguistic variables.
\begin{xtxt}
 <nonterminal> ::= sequence
\end{xtxt}
The sequence consists of one or more nonterminals or terminals and may contain a vertical bar to indicate a choice. The whole sequence replaces the symbol on the right. The extended Backus-Naur Form (EBNF) is a family of BNF dialects with the same power as BNF, but with improved readability. Common extensions are grouping, the Kleene star denoting a zero or more multiplicity, the Kleene cross denoting a multiplicity of one or more and an option denoting a multiplicity of zero or one. \cite{ParserBook}
 
% H I J K %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{Kleene Star} 
The (Kleene) closure of a language $L$, denoted $L^*$, is the set of strings received by concatenating $L$ zero or more times. \cite{DragonBook}

% L	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{Language} 
A language is any countable set of words over some fixed alphabet. The set of all context-free languages is identical to the set of languages that is accepted by pushdown automaton. \cite{DragonBook}

\paragraph{Language Element} The term \emph{Language Element} is used in this thesis to denote an \code{EObject} instance of a Metaclass of the language Metamodel. This is transferable to other Metamodels, for example, Notation element, etc.

\paragraph{Language Workbench}
A Language Workbench is a generic tool to build software around a set of domain specific languages. The key concept is that editing is not done on text files but on the \emph{abstract} representation of a program \cite{Fowler}. This enables the following characteristics:
\begin{itemize}
	\item languages are closed under composition.
	\item users edit this abstract structure using projectional editors.
	\item a language has three main parts: abstract structure definition, editor(s) and optional generators or interpreters.
\end{itemize}
In practice, the term Language Workbench is often used for frameworks that support language creation to a greater extent than ``compiler compiler'' or parser generators. The bidirectionality of abstract structure and concrete editors is especially often ``eased''. 

\paragraph{Lexeme}
A lexeme is a sequence of characters on the character stream that matches a specific token pattern and is identified by the lexical analyzer as an instance of that token \cite{DragonBook}.

%  M N %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{Metaclass} If the model class $c$ is an instance of the class $M$, $M$ is the Metaclass of $c$.

\paragraph{Meta Metamodel} A Meta Metamodel is a model that describes Meta Models. Meta Metamodels, like Ecore and Meta Object Facility, are self descriptive: their metaclasses can be used to describe themselfs, so they are their own Meta Model \cite{EMF2nd}. 

\paragraph{Meta Model} The structure of a language is captured in its Metamodel. A Metamodel \emph{is a model} that provides the basis for constructing other, so called, instance models \cite{EMP}. The Meta Model defines the Abstract Syntax and optionally the Static Semantics of a language \cite{MDSD}.

\paragraph{Model} A Model or instance Model is an instance of a Metamodel.


\paragraph{Lexer}
A Lexer, also denoted as lexical analyzer, allows a parser to treat multi-character constructs, like identifiers, as units called tokens during syntax analysis. \cite{DragonBook}



% O P Q R %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\paragraph{Parsing} 
``Parsing is the process of structuring a linear representation in accordance with a given grammar.'' \cite{ParserBook}.

\paragraph{Parse Forest} 
A set of parse trees. If duplicated subtrees are combined, the resulting structure is called a parse graph. \cite{ParserBook}

\paragraph{Parse Tree}
Given a context-free grammar, a parse tree, according to the grammar, is a tree with these properties \cite{DragonBook}:
\begin{enumerate}
	\item the start symbol is the roots label.
	\item The leafs are labeled by a terminal or by $\epsilon$.
	\item Interior nodes are labeled by nonterminals.
	\item If $A$ is a nonterminal, which labels an interior node and $X_1, X_2, . . . , X_n$ are the labels of the children of that node from left to right, then there must be a production $A  \rightarrow X_1X_2 ... X_n$. So $X_1, X_2, ... , X_n$ stand for a symbol each of which is either a terminal or a nonterminal. If $A\rightarrow c$ is a production, then a node labeled $A$ may have a single child labeled $\epsilon$ as a special case. 
\end{enumerate}
% S T U
\paragraph{S-Attributed Grammar} 
An Attributed Grammar formally defines a way to attach attributes to tree nodes created in regards to production rules of a formal grammar. If the evaluation rule of an attribute value only depends on its children, it's called a synthesized attribute. An S-Attributed Grammar is an Attributed Grammar which is only based on \emph{synthesized} attributes. The evaluation of S-attributed grammars can be incorporated in top-down, as well as in bottom-up parsing. \cite{ParserBook}

\paragraph{Sentential Forms}   
The intermediate form for creating sentences from a formal grammar are called sentential forms. \cite{ParserBook}

\paragraph{Stable versus Unstable Models}
This thesis uses these terms to distinguish the stability of references to model elements. Stability is no intrinsic characteristic of the model, but a contract of all model manipulation parties. Models which elements are \emph{updated} if edited are called ``Stable Models''. If the model, or parts of it are \emph{replaced} by equal model elements, the model is \emph{unstable}. The worst case of unstable models is the creation of an completely new equal model if an editor commits an empty update.

\paragraph{Static Semantics} The Static Semantics defines well-formedness constraints. \cite{MDSD}

\paragraph{Subtree} Subtree denotes a branch of a tree.

\paragraph{Syntax \& Semantic}  
The syntax of a language describes its proper form, while the semantics of the language defines what it means. \cite{DragonBook}

\paragraph{Syntax Directed Editor or Projectional Editor} A Projectional Editor allows the user to directly edit the AST representation of the code or the structure of the document \cite{MPS}. In general, syntax-directed editors allow partial presentations of the document and offer support for the interpretation extra state, for example, as built-in tree views on the document structure \cite{proxima}.

\paragraph{Syntax Recognizing Editor or Syntax Aware Editor} A syntax-recognizing text editor is one in which the user provides text and the system infers the syntactic structure by analysis \cite{pan}. 

\paragraph{Tokens \& Terminals}  
A token consists of a name and an attribute value. The names are abstract symbols used by the parser for syntax analysis. These token names are often called terminals. The attribute value contains additional information. \cite{DragonBook}

% V W X Y Z 
\paragraph{Word} 
A word over an alphabet is a finite sequence of symbols drawn from that alphabet. In language theory, the terms \emph{sentence}, \emph{word} and \emph{string} are used as synonyms. \cite{DragonBook}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\section{General Approaches} \label{sec:generalApproaches}
This section provides a selected overview of current language and editing approaches which are not Metamodel based. This includes Language Workbenches, tools to develop Domain Specific Languages, projectional and textual editors.

\subsection{ANTLR}
ANTLR \footnote{\raggedright \url{http://www.antlr.org/}}, ``ANother Tool for Language Recognition'', is an open source parser generator framework for LL(*) parsers with selective backtracking. It allows the creation of Java parsers and lexers from a grammar file. The grammar file contains among other things an EBNF grammar with actions \cite{ANTLR}.

\subsection{Barista}
Barista \footnote{\raggedright \url{http://www.cs.cmu.edu/~NatProg/barista.html}} is an editor framework for user interfaces that offers alternative structured visual representations on an internal abstract syntax tree. It uses Citrus \footnote{\raggedright \url{http://www.cs.cmu.edu/~NatProg/citrus.html}} as a user interface toolkit \cite{citrus} and adds data structures and a textual interaction technique to it. It mimics the interaction technique of conventional text editors to overcome a central usability problem of previously structured code editors by fluidly changing between structured and unstructured text. It is based on the model view controller pattern \cite{patterns} and the presented editors structure depends on the models structure. The model in Barista consists of \emph{Structures} and \emph{Tokens}. Structures are tree nodes and Tokens the leafs. A Token is assigned to a property of a Structure and is contained in it. For each Structure, a grammar is inferred or provided and for each Token, a regular expression is specified that defines its legal strings and white space. The general idea of Barista's textual interaction technique is to unparse, retokenize and reparse a Token if its value is not part of the language described by the regular expression. Barista uses a variant of \cite{iglrPaper} incremental parsing Algorithm to reuse the abstract syntax tree's structure \cite{Barista}. 

\subsection{Harmonia}
The Harmonia Research Project \footnote{\raggedright \url{http://harmonia.cs.berkeley.edu/harmonia/}} is a framework for constructing interactive
language-based programming tools. It emerged from two earlier prototypes: \emph{PAN} and \emph{ENSEMBLE}. Harmonia's goal is to facilitate building interactive tools, so the provided services are \emph{incremental} and the internal program representation maintained by the framework is \emph{updated} as a program is manipulated. Harmonia provides syntactic and semantic analysis services \cite{harmonia} and can be used to augment text editors with language aware editing and navigation functionality. Harmonia adopts from ENSEMBLE the incremental Lexer algorithm \cite{ilex} and the incremental Parser algorithm \cite{iglrPaper}. Incremental parsing utilizes persistent parse trees and the parse input consists of both terminal and \emph{nonterminal} symbols \cite{iglrPaper}. Ensemble also has a graphical presentation formalism based on tree transformations \cite{ensemble}. This transformed graphical notation is not editable.

\subsection{Integrated Development Environments}
Integrated Development Environments (IDEs) like Eclipse, IntelliJ IDEA, Netbeans and Visual Studio parse the source code as it is typed; this is called Background Parsing. They use the parsed abstract syntax tree to provide editor services like outlining, refactoring, error marking and content completion. These are syntax-recognizing editors. LavaPE \footnote{\raggedright \url{http://lavape.sourceforge.net/}} is an example of an IDE with a syntax directed editor.  

\subsection{JetBrains Meta Programming System}
JetBrains Meta Programming System \footnote{\raggedright \url{http://www.jetbrains.com/mps/}} is an Java based open source language workbench, which allows to define the abstract syntax of a language, a projectional editor and model transformation. In the Meta Programming System, the abstract syntax of a \emph{Language} is defined using \emph{Concepts}. Model nodes are defined by their concepts \cite{MPStut}. The terminology in the Meta Programming System abstract syntax is Language, Solution and Concept, where Language is similar to a Metamodel, Solution to a Model and Concept to a Metaclass. It provides a projectional editor that directly edits the abstract language instance directly. The editor focuses on text presentation, but it is not free, but form oriented text. At the time of writing, tables are the only editable graphical notation. Also, a Concept is either presented textually \emph{or} as a table. A Solution can then be transformed by textual model to model transformations to one of  Meta Programming Systems several base languages, which provide the semantics of the language constructs. As base languages, there is currently C, Java, XML or plain text available. Because the textual notations in the Meta Programming System are not free text, it requires the user to change his ``editing habits'' \cite{VolterMPS}. 

\subsection{Proxima} 
Proxima \footnote{\raggedright \url{http://www.cs.uu.nl/wiki/bin/view/Proxima}} is a generic structure editor written in Haskell for a range of structured documents. It allows free text editing as well as structure editing. Proxima maintains a bidirectional mapping between the document structure and its presentation, by a multiplicity of bidirectional mappings between the seven layers of Proxima's architecture. Proxima does not use conventional parsing techniques, because the presentation in not restricted to text, but also contains graphical elements. Graphical presentation can not be edited directly at the presentation level \cite{beyond_ascii}. Proxima uses \emph{structural tokens} for presentation that are not strings and treats them specially \cite{proxima}.

\subsection{Spoofax}
Spoofax \footnote{\raggedright \url{http://strategoxt.org/Spoofax}} is an Eclipse based framework to develop textual domain specific languages with IDE support \cite{Spoofax}. Spoofax uses the Syntax Definition Format \footnote{\raggedright \url{http://syntax-definition.org/}} (SDF2) to specify the syntax \cite{Spoofax}. It combines the specification of concrete and abstract syntax into a single grammar. SDF defines context free grammar like EBNF \cite{sdf}, but it is among other things modular and together with scannerless generalized parser like \cite{sglr} and declarative disambiguation rules, it is freely composeable. Spoofax uses Stratego \footnote{\raggedright \url{http://strategoxt.org}}, a term rewriting or transformation tool \cite{stratego}, to process the abstract syntax trees. The abstract representation is, in contrast to EMF, based on trees.






