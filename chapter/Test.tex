\chapter{non}

\section{Overivew}

The first conceptional improvement of this thesis allows \emph{switchable textual representations}. This has been solved by extending the parse tree constructor and by providing a hint to guide the parse tree construction. A hint identifies the next production part.
The parse tree constructor is conceptually extended to
\begin{enumerate}
	\item determine all valid solutions for a node and assign them to it and
	\item to prefer certain hints while the resulting parse tree is constructed.
\end{enumerate}
For combined use with the parse tree constructor a Notation model was developed to
\begin{itemize}
	\item provide a proper place to assign alternative presentations and
	\item to uniquely identify productions or parts of it as hints.
\end{itemize}
To uniquely distinguish a specific tree construction for hints, the structure resembled a parse tree structure. The notation model was extended to substitute the parse tree accordingly.\\


\emph{Structured Tokens} highlighted the usage of nested structured data, like \code{EObject}s as Tokens, which triggered the second conceptional improvement. To integrate Structured Tokens in a textual serialization, a Structured Character concept was developed. It is based on the basic idea to use a private, unique character as a key for a map entry of a data structured persisted in an adjacent resource, like a file. The designated solution are UTF8 private use characters and a wrapping Lexer which resolves and types the \code{EObject}s from the adjacent resource. This enables the use of \code{EObject}s as atomic characters on the character stream. \\

The possibility to use \code{EObject} on the character stream enables the use of Notation model elements on it. Notation model elements represent parts of the Parse Tree or \emph{Sentential Forms}. To allow their use as \emph{Sentential Token} two improvements are necessary:
\begin{itemize}
	\item The extended Lexer must assign the Token name of the Sentential Token properly. The name can not be determined by the generic Notation model elements type, but by a general Notation Metamodel specific rule, which resolves the grammar relation of the Notation element.
	\item The input grammar for the used Parser generator must be post processed, so that each non terminal on the right hand side of a rule is replaced by a new alternative. The new alternative consists of the original non terminal $\overline{or}$\footnote{\raggedright Metalinguistic or. See \cite{BNF}} a terminal with the synthetic name of the grammar related element, which would be assigned by the Lexer.
\end{itemize}
Serialized Sentential Tokens are named \emph{Sentential Characters}. Sentential Characters alone simply hide the data structure of a production part in one character and perfectly integrate in the language described by the context free grammar grammar. \\

To improve the usability of \emph{Structured Characters} for Presentation, following enhancements are suggested:
\begin{itemize}
	\item Extensible Parse Tree Constructor, which optionally specializes the determined type based on additional constraints. This is similar to GMFs Extensible Type Registry.
	\item To omit Parse Tree construction if a specialized presentation type was found. A graphical editor could then safely operate on the Language model elements.
\end{itemize}
A user interface could create a graphical editor at the place of his specific specialized presentation character and operate on the Language model elements it hides.\\


Finally, the problem of unstable models and its impact on the suggested solution is resumed as part of the discussion.


\section{Problems of current Model Text Bridges}
\begin{itemize}
	\item Rule := Controller?
	\item Problem solutions of other frameworks are suggested.
\item how are updates handled (equality vs. IDs) \\
		- what's their scope (replace whole tree, substree) \\
		-	reuse of nodes (incremental parser reuse nodes to save time, not to keep identity)
\end{itemize}	

\section{what misses? Text <-> Model sync}

%	-------------- Latex testing --------------
The Notation model is an EMF model to describe a tree. A node or leaf contains a reference to the describing language model element.The notation model bridges the token stream and the abstract syntax. It is the parse tree, and thus also describes a valid concrete syntax representation of the model.  It is a mandatory to updated or created it when generating a concrete representation of the model. If the notation model (element) was created to complement a language model (element), the notation model (element) serves as a disambiguis bulding plan to create the token stream for a valid concrete representation. In gereral, the notation model saves information which is not stored in the language model but relevant for presentation. It also keeps a generic, type save reference on the represented language object.\\
Each notation element represents (part of) a language element and should be a stable container for different visual representations of that element with addionaly layout information.  Due to this, if an element has multiple semantically equivalent representations, it is possible to switch the representation without switching the notation element. A switch would invalidade the descendants of the current node. A notion element therefore contains a transient structural feature containing all possible valid concrete representation rules, the non-transient last representation rule and optional the last user selected representation rule. In case these representation rules are grammar rules, they must be complemented with addionional information in order to make the token production unambigious. For example a grammar rule like:
\begin{xtxt}
A : (B | C) "myKeyword"
\end{xtxt}
would be translated to the following productions rules 
\begin{xtxt}
A - > B "myKeyword"
A - > C "myKeyword"
\end{xtxt}
for the sake of abstraction and simplicity, this distinction, especially im more complex scenarios, should be hidden from the language developer. In a case where B and C are semantically equivalent  it is arbitrary from the abstract syntax perspective if an A contains a B or C. The notation element must close this gap, so an notation element refering to a lanuage element represented by A doesn't need to store the keyword "myKeyword", this information is implicit, but it must distinguish if the concrete presentation of this particular A should use B or C as a presentation selection. It is therefore not nessecary to explicity assign  a production rule but to implicity make one resolvable by dissolving the ambiguity for options and choices which have no representation in the language model. \\
The base class for representation rules must be general, or unspecific, enough allow non textual representations. Notation elements should prefer containment references instead of attributes to easy to ease merging, like the GMF notation model. In contrast to GMF, this driving motivation is not team support but easier automatic updating between old and new versions.\\
In order to integrate with incremental parsing, notation model elements should hold a transient integer which contains the distance to the first previous token accesing the current one in it's lookahead. \\
Finally, a notation model element should contain a flag if it is currently textually visible.
\todo{ rewrites possible}
\todo{ reason that a representation in text editor is necessary}
\todo{mention that addtionaly layout information can be added to a node}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Extra TODO}

\begin{itemize}
	\item glossar
	\item Parser Autocomplete (Overview 3, Artifical Tokens 13)
	\item GLL zu EMF?
	\item tupel im diagramm zu tuple
\end{itemize}

%\begin{figure}
%\includegraphics[scale=0.7]{gfx/ex/grammarExample} 
%\caption{Example Rule ``A := (w |x y)+ B? | z C''}
%\end{figure}
%\FloatBarrier
 

%\begin{figure}
%% %\import{gfx/svgExport/}{grammarExample.eps_tex}
%  \centering
%  \includegraphics[scale=1.00]{gfx/temp/fhw} 
%  \caption{Schematic data flow for a web application}
%  \label{fig:architecture:web_app_usage}
%\end{figure}

\section{Missing}

TODO
\begin{itemize}
	\item Suggest text representation for: 
	\begin{itemize}
		\item editing (with STokens)
		\item serialization (with mixed XMI containments)
		\item presentation (wo/ IDTokens)?
	\end{itemize}
	
	\item Explain intermixed Txt, Graph, Txt
	\item Mention existence of unassigned values in a choice but not in AST (``blla'' | ``blubb'' )and defaults

	\item embrace ambiguity
	\item ambiguity vs non-determinism

	

Refs:
	\item Widen meaning of Annotation?
	\item solved incomplete information but can specialization types be handled if just supertypes are known? 
	\item Mention that SAEBNF ? MM constrain each other
	\item Lazy Obj creation means on first access
	\end{itemize}

synthetic constraints for grammar rules?

\begin{itemize}
	\item Is it, and if how is it possible to present textual views on a model which present a different structure than the underlying model (annotations).
		\item  How are updates handled?
\end{itemize}

check abstract and transient for models 